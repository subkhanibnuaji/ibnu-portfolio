/**
 * Client-side File Generators
 * File: lib/ai/file-generators.ts
 *
 * Utilities for generating PDF and presentation files in the browser.
 * Uses dynamic imports to avoid SSR issues.
 */

// ============================================
// PDF GENERATOR
// ============================================

export interface PDFData {
  title: string;
  content: string;
  author?: string;
}

export async function generatePDF(data: PDFData): Promise<void> {
  // Dynamic import to avoid SSR issues
  const { jsPDF } = await import('jspdf');

  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 20;
  const maxWidth = pageWidth - margin * 2;

  // Title
  doc.setFontSize(24);
  doc.setFont('helvetica', 'bold');
  doc.text(data.title, margin, 30);

  // Author
  if (data.author) {
    doc.setFontSize(12);
    doc.setFont('helvetica', 'italic');
    doc.setTextColor(100);
    doc.text(`By: ${data.author}`, margin, 40);
    doc.setTextColor(0);
  }

  // Separator line
  doc.setDrawColor(200);
  doc.line(margin, 45, pageWidth - margin, 45);

  // Content
  doc.setFontSize(12);
  doc.setFont('helvetica', 'normal');

  const lines = doc.splitTextToSize(data.content, maxWidth);
  let y = 55;
  const lineHeight = 7;

  for (const line of lines) {
    if (y > 280) {
      doc.addPage();
      y = 20;
    }
    doc.text(line, margin, y);
    y += lineHeight;
  }

  // Footer
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(10);
    doc.setTextColor(150);
    doc.text(
      `Generated by IbnuGPT Agent | Page ${i} of ${pageCount}`,
      pageWidth / 2,
      290,
      { align: 'center' }
    );
  }

  // Save
  doc.save(`${data.title.replace(/[^a-z0-9]/gi, '_')}.pdf`);
}

// ============================================
// PPT/PRESENTATION GENERATOR (HTML-based)
// ============================================

export interface PPTData {
  title: string;
  slides: string;
  theme?: string;
}

const THEME_COLORS: Record<string, { primary: string; secondary: string; bg: string }> = {
  blue: { primary: '#0066CC', secondary: '#003366', bg: '#f0f8ff' },
  green: { primary: '#00AA44', secondary: '#005522', bg: '#f0fff0' },
  red: { primary: '#CC0033', secondary: '#660022', bg: '#fff0f0' },
  purple: { primary: '#6633CC', secondary: '#331166', bg: '#f8f0ff' },
  orange: { primary: '#FF6600', secondary: '#993300', bg: '#fff8f0' },
};

export async function generatePPT(data: PPTData): Promise<void> {
  const colors = THEME_COLORS[data.theme || 'blue'] || THEME_COLORS.blue;

  // Parse slides
  const slideContents = data.slides.split('---').map(s => s.trim()).filter(Boolean);

  // Generate HTML presentation
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(data.title)}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a2e; }
    .presentation { width: 100%; min-height: 100vh; }
    .slide {
      width: 100%;
      min-height: 100vh;
      padding: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      background: white;
      page-break-after: always;
      border-bottom: 4px solid ${colors.primary};
    }
    .slide-title {
      font-size: 48px;
      font-weight: bold;
      color: ${colors.secondary};
      margin-bottom: 40px;
      border-left: 6px solid ${colors.primary};
      padding-left: 20px;
    }
    .slide-content {
      font-size: 24px;
      line-height: 1.8;
      color: #333;
    }
    .slide-content ul {
      list-style: none;
      padding-left: 20px;
    }
    .slide-content li {
      margin-bottom: 16px;
      padding-left: 30px;
      position: relative;
    }
    .slide-content li::before {
      content: "•";
      color: ${colors.primary};
      font-size: 32px;
      position: absolute;
      left: 0;
      top: -4px;
    }
    .title-slide {
      background: linear-gradient(135deg, ${colors.secondary} 0%, ${colors.primary} 100%);
      text-align: center;
      justify-content: center;
      align-items: center;
    }
    .title-slide .slide-title {
      color: white;
      font-size: 64px;
      border: none;
      padding: 0;
      margin-bottom: 20px;
    }
    .title-slide .subtitle {
      color: rgba(255,255,255,0.8);
      font-size: 28px;
    }
    .end-slide {
      background: linear-gradient(135deg, ${colors.primary} 0%, ${colors.secondary} 100%);
      text-align: center;
      justify-content: center;
      align-items: center;
    }
    .end-slide .slide-title {
      color: white;
      font-size: 64px;
      border: none;
    }
    .footer {
      position: fixed;
      bottom: 20px;
      width: 100%;
      text-align: center;
      color: #999;
      font-size: 14px;
    }
    @media print {
      .slide { page-break-after: always; }
      .footer { display: none; }
    }
    /* Navigation for HTML view */
    .nav-hint {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
    }
    @media print { .nav-hint { display: none; } }
  </style>
</head>
<body>
  <div class="presentation">
    <!-- Title Slide -->
    <div class="slide title-slide">
      <h1 class="slide-title">${escapeHtml(data.title)}</h1>
      <p class="subtitle">Generated by IbnuGPT Agent</p>
    </div>

    <!-- Content Slides -->
${slideContents.map(slide => {
  const lines = slide.split('\n').filter(Boolean);
  const slideTitle = lines[0] || 'Slide';
  const bulletPoints = lines.slice(1);
  return `    <div class="slide">
      <h2 class="slide-title">${escapeHtml(slideTitle)}</h2>
      <div class="slide-content">
        <ul>
${bulletPoints.map(point => `          <li>${escapeHtml(point.replace(/^[-•*]\s*/, ''))}</li>`).join('\n')}
        </ul>
      </div>
    </div>`;
}).join('\n\n')}

    <!-- End Slide -->
    <div class="slide end-slide">
      <h2 class="slide-title">Thank You!</h2>
    </div>
  </div>
  <div class="nav-hint">Scroll to navigate | Print (Ctrl+P) to save as PDF</div>
</body>
</html>`;

  // Download as HTML file
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${data.title.replace(/[^a-z0-9]/gi, '_')}_presentation.html`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Helper function to escape HTML
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
}

// ============================================
// CONVERSATION EXPORT
// ============================================

export interface ConversationMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface ConversationExport {
  title?: string;
  messages: ConversationMessage[];
  model?: string;
  exportedAt?: Date;
}

/**
 * Export conversation to Markdown format
 */
export function exportToMarkdown(data: ConversationExport): void {
  const title = data.title || 'Chat Conversation';
  const date = (data.exportedAt || new Date()).toLocaleString();

  let markdown = `# ${title}\n\n`;
  markdown += `**Exported:** ${date}\n`;
  if (data.model) {
    markdown += `**Model:** ${data.model}\n`;
  }
  markdown += `\n---\n\n`;

  for (const msg of data.messages) {
    const roleLabel = msg.role === 'user' ? '**You:**' : msg.role === 'assistant' ? '**AI:**' : '**System:**';
    markdown += `${roleLabel}\n\n${msg.content}\n\n---\n\n`;
  }

  markdown += `\n*Generated by IbnuGPT Agent at heyibnu.com*\n`;

  // Download as .md file
  const blob = new Blob([markdown], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().slice(0, 10)}.md`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Export conversation to PDF format
 */
export async function exportToPDF(data: ConversationExport): Promise<void> {
  const { jsPDF } = await import('jspdf');

  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 20;
  const maxWidth = pageWidth - margin * 2;

  const title = data.title || 'Chat Conversation';
  const date = (data.exportedAt || new Date()).toLocaleString();

  // Title
  doc.setFontSize(20);
  doc.setFont('helvetica', 'bold');
  doc.text(title, margin, 25);

  // Metadata
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100);
  doc.text(`Exported: ${date}`, margin, 35);
  if (data.model) {
    doc.text(`Model: ${data.model}`, margin, 42);
  }
  doc.setTextColor(0);

  // Separator
  doc.setDrawColor(200);
  doc.line(margin, 48, pageWidth - margin, 48);

  let y = 58;
  const lineHeight = 6;

  for (const msg of data.messages) {
    // Check if we need a new page
    if (y > 260) {
      doc.addPage();
      y = 20;
    }

    // Role label
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(msg.role === 'user' ? 0 : 50, msg.role === 'user' ? 100 : 100, msg.role === 'user' ? 200 : 150);
    const roleLabel = msg.role === 'user' ? 'You:' : msg.role === 'assistant' ? 'AI:' : 'System:';
    doc.text(roleLabel, margin, y);
    y += lineHeight + 2;

    // Content
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(0);

    const lines = doc.splitTextToSize(msg.content, maxWidth);
    for (const line of lines) {
      if (y > 280) {
        doc.addPage();
        y = 20;
      }
      doc.text(line, margin, y);
      y += lineHeight;
    }

    y += 8; // Space between messages
  }

  // Footer on all pages
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setTextColor(150);
    doc.text(
      `Generated by IbnuGPT Agent | heyibnu.com | Page ${i}/${pageCount}`,
      pageWidth / 2,
      290,
      { align: 'center' }
    );
  }

  // Save
  doc.save(`${title.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().slice(0, 10)}.pdf`);
}

/**
 * Export conversation to JSON format (for backup/import)
 */
export function exportToJSON(data: ConversationExport): void {
  const jsonData = {
    ...data,
    exportedAt: (data.exportedAt || new Date()).toISOString(),
    generator: 'IbnuGPT Agent',
    website: 'heyibnu.com'
  };

  const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `conversation_${new Date().toISOString().slice(0, 10)}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
